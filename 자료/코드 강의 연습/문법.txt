//Nullable 
int b = number ?? 0;
int b = (number != null) ? number.Value : 0;
int? id = monster?.Id;
if (monster == null)
{
id = null;
}
else
{
id = monster.Id;
}

// Reflection : X-Ray

//Anonymous Function : 무명 함수 / 익명 함수
//Item item = FindItem(delegate (Item item) { return item.ItemType == ItemType.Weapon; });

//Lambda : 일회용 함수를 만드는데 사용하는 문법
//Item item = FindItem((Item item) =>{ return item.ItemType == ItemType.Weapon; });

//delegate(대리자) 콜백
//delegate를 직접 선언하지 않아도 이미 만들어진 애들이 존재
//반환 타입이 있으면 Func
//반환 타입이 없으면 Action

//Property
public int Hp{get; set;}
//interface
//abstract
//Generic(일반화)
class MyList<T>()
{
	
}
//딕셔너리
dic.Add(1, new Monster(1));
dic[5] = new Monster(5);
//주어진 키에 존재하는지 확인하는 법
Monster mon;
bool found = dic.TryGetValue(20000,out mon);
//리스트
List<int> list = new List<int>();
//삽입 list.Insert(2, 999); 두번째 인덱스에 999를 넣기
//삭제 list.Remove(3); 3이라는 숫자를 삭제 3이 여러개있으면 인덱스가 제일 낮은 3이 삭제
list.RemoveAt(0); 0번째 인덱스 숫자를 삭제
list.Clear(); 전체 삭제
//리스트 길이 list.Count

//다차원 배열
int[,] arr = new int[2,3] { {1, 2, 3 },{1, 2, 3 } };
int[,] arr = new int[,] { {1, 2, 3 },{1, 2, 3 } };
int[,] arr = { {1, 2, 3 },{1, 2, 3 } };
//배열
int[] scores = new int[5] { 10, 20, 30, 40, 50 };
int[] scores = new int[] { 10, 20, 30, 40, 50 };
int[] scores = { 10, 20, 30, 40, 50 };
배열의 길이 scores.Length
static int GetHighestScore(int[] scores) 큰수 찾기
        {
            int maxValue = 0;
            foreach (int score in scores)
            {
                if(score > maxValue) maxValue = score;
            }
            return maxValue;
        }
        static int GetAverageScore(int[] scores) 평균값
        {
            if (scores.Length == 0) return 0;
            int sum = 0;
            foreach (int score in scores)
            {
                sum += score;
            }          
            return sum / scores.Length;
        }
        static int GetIndexOf(int[] scores, int value) 인덱스값 찾기
        {
            if (scores.Length == 0) return -1;
            for (int i = 0; i<scores.Length; i++)
            {
                if (value == scores[i]) return i;
            }
            return -1;
        }
        static void Sort(int[] scores) 오른차순
        {
            for (int i = 0; i < scores.Length; i++)
            {
                int minIndex = i;
                for (int j = i; j < scores.Length; j++)
                {
                    if (scores[j] < scores[minIndex]) minIndex = j;
                }
                int temp = scores[i];
                scores[i] = scores[minIndex];
                scores[minIndex] = temp;
            }
        }
//문자열
string name = "Harry Potter";
//1. 찾기            
bool found = name.Contains("Harry");해당 문자열이 존재하는지            
int index = name.IndexOf('a'); 몇번째 인덱스에 있는지

//2. 변형
name = name + " Junior"; 문자열 추가
string lowerCaseName = name.ToLower(); 소문자로 모두 변형
string upperCaseName = name.ToUpper(); 대문자로 모두 변형
string newName = name.Replace('r', 'l'); 해당 문자 전부를 다른 문자로 변형

//3. 분할
string[] names = name.Split(new char[] { ' ' });해당 문자를 기준으로 분할
string substringName = name.Substring(5); 몇번째 인덱스까지 자르기

오버로딩(함수 이름의 재사용)
오버라이딩(다형성을 이용)

//캐스팅이 제대로 되었는지 확인 하는 방법 (as, is)
bool isMage = player is Mage;
if (isMage)
{
Mage mage = (Mage)player;
mage.mp = 10;
}

Mage mage = player as Mage;
if (mage != null)
{
mage.mp = 10;
}

//OOP(객체지향) 은닉성/상속성/다형성

//접근 한정자 (사용 안했을때는 자동으로 private)
public 모든 사용자에게 공유
protected 상속자에게 공유
private 자신만 사용
static 오로지 1개만!

class는 ref 참조
struct는 복사

//디버깅(영화 인셉션과 비유)
F9 브레이킹포인트 (빨간색원)
F11 다음 실행 순서로 이동
F10 실행되는 메인(현실)에서 함수실행이 있을때 함수 실행 순서(꿈)까지 안보고 이동 
// 복사(짭퉁) 참조(진퉁) ref(레퍼런스)를 사용

// 삼항 연산자 (조건 ? 참일때 : 거짓일때)
int num = 25;
bool isPair = ((num % 2) == 0 ? true : false);

//연산 순위
1. ++ --
2. * / %
3. + -
4. << >>
5. < >
6. == !=
7. &
8. ^
9. |
10. ...

// << >> &(and) |(or)  ^(xor)두값이 다르면 켜짐  ~(not)

//xor 암호화하는데 자주 쓰임
int id = 123;
int key = 401;
int a = id ^ key;
int b = a ^ key;
Console.WriteLine(a);
Console.WriteLine(b); 123

// 1. 바구니 크기가 다른경우 캐스팅
int a = 1000;
short b = (short)a;

// 2. 바구니 크기가 같은데 부호가 다른경우 캐스팅
byte c = 255;
sbyte sb = (sbyte)c;
// underflow(언더플로우), overflow(오버플로우)
// 0xFF = 0b11111111 = -1

// 3. 소수
float f = 3.1414f;
double d = f;
값이 정확하지않음

//byte(1바이트 0~ 255). short(2바이트 -3만 ~ 3만), int(4바이트 -21억 ~21억), long(8바이트)
//sbyte(1바이트 -128~ -127), ushort(2바이트 0~6만), uint(0~43억), ulong(8바이트)

//10진수
// 00 01 02 03 04 05 06 07 08 09
//10

// 2진수
//0~1
//0b00 0b01 0b10 0b11 0b100 0b101 0b110 0b111
// 0b10001111 = 0x8F
// 16진수
// 0~9 a b c d e f
//0x00 0x01 0x02 ... 0x0F
// 0x10

//1바이트(참/거짓)
bool b;
b = true;
b = false;

//소수
// 4바이트
float f = 3.14f;

// 8바이트
double d = 3.14;

//2바이트
char c = 'a';
string str = "Hello world";